(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{230:function(r,t,e){"use strict";e.r(t);var v=e(0),a=Object(v.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var r=this,t=r.$createElement,e=r._self._c||t;return e("div",{staticClass:"content"},[e("h1",{attrs:{id:"jvm内存粗浅分析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#jvm内存粗浅分析","aria-hidden":"true"}},[r._v("#")]),r._v(" JVM内存粗浅分析")]),r._v(" "),e("h2",{attrs:{id:"内存类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#内存类型","aria-hidden":"true"}},[r._v("#")]),r._v(" 内存类型")]),r._v(" "),e("p",[r._v("分为堆（heap）和栈（strak）。")]),r._v(" "),e("p",[r._v("堆的分代:eden代，Survivor新生代和老年代。")]),r._v(" "),e("p",[r._v("对象 出生于eden代，如果经历过一次 GC后仍旧存活，则会进入Survivor, Survivor分为两部分，一个为to，一个为from。由于采用复制算法，都会保证to区为空。每次经历一次Minor GC，from与to区都会换名字一次，且把依旧存活的存入to区。等到一定的年龄后（或to区满了之后），则会进入老年代。")]),r._v(" "),e("h2",{attrs:{id:"内存申请过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#内存申请过程","aria-hidden":"true"}},[r._v("#")]),r._v(" 内存申请过程")]),r._v(" "),e("ol",[e("li",[r._v("JVM试图为对象在Eden中申请一块内存区域。")]),r._v(" "),e("li",[r._v("当内存足够，则申请结束，否则下一步。")]),r._v(" "),e("li",[r._v("JVM试图释放Eden中不活跃的对象；释放后若仍不足，则部分Eden中的对象放入Survivor和OLD区。")]),r._v(" "),e("li",[r._v("当OLD区足够时，则Survivor的对象会转移到OLD区，否则保留在Survivor。")]),r._v(" "),e("li",[r._v("当OLD不够时，JVM会在OLD中进行0完全垃圾回收。")]),r._v(" "),e("li",[r._v("完全垃圾回收后，Survivor及OLD区扔无法存放Eden复制来的部分对象，导致无法在Eden中创建对象，则出现outofmemory。")])])])}],!1,null,null,null);t.default=a.exports}}]);