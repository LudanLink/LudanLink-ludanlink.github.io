<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>并发常见问题 | 白 日 淡</title>
    <meta name="description" content="空空而来，又怎能空空而去">
    <link rel="icon" href="/logo.png">
  <link rel="manifest" href="/manifest.json">
  <meta name="theme-color" content="#3eaf7c">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <link rel="apple-touch-icon" href="/icons/apple-touch-icon-152x152.png">
  <link rel="mask-icon" href="/icons/safari-pinned-tab.svg" color="#3eaf7c">
  <meta name="msapplication-TileImage" content="/icons/msapplication-icon-144x144.png">
  <meta name="msapplication-TileColor" content="#000000">
    
    <link rel="preload" href="/assets/css/0.styles.0d19fd84.css" as="style"><link rel="preload" href="/assets/js/app.07421936.js" as="script"><link rel="preload" href="/assets/js/19.43aa5948.js" as="script"><link rel="prefetch" href="/assets/js/10.da7d1ee6.js"><link rel="prefetch" href="/assets/js/11.b2419c0a.js"><link rel="prefetch" href="/assets/js/12.91038659.js"><link rel="prefetch" href="/assets/js/13.16f6d96c.js"><link rel="prefetch" href="/assets/js/14.717547c1.js"><link rel="prefetch" href="/assets/js/15.7024b64f.js"><link rel="prefetch" href="/assets/js/16.e6fd1184.js"><link rel="prefetch" href="/assets/js/17.5ade8dfb.js"><link rel="prefetch" href="/assets/js/18.98b5a4b1.js"><link rel="prefetch" href="/assets/js/2.9c18cab0.js"><link rel="prefetch" href="/assets/js/20.fffefcad.js"><link rel="prefetch" href="/assets/js/21.aadaff04.js"><link rel="prefetch" href="/assets/js/22.ad8ef7fa.js"><link rel="prefetch" href="/assets/js/23.fc9bc37b.js"><link rel="prefetch" href="/assets/js/24.e3406894.js"><link rel="prefetch" href="/assets/js/25.b5a9fc9b.js"><link rel="prefetch" href="/assets/js/26.1b5eae32.js"><link rel="prefetch" href="/assets/js/27.c85a8cc9.js"><link rel="prefetch" href="/assets/js/28.85b53558.js"><link rel="prefetch" href="/assets/js/29.c96a2c43.js"><link rel="prefetch" href="/assets/js/3.3e457bc3.js"><link rel="prefetch" href="/assets/js/30.a9cf47bf.js"><link rel="prefetch" href="/assets/js/31.35767153.js"><link rel="prefetch" href="/assets/js/32.da2a97a5.js"><link rel="prefetch" href="/assets/js/33.54660318.js"><link rel="prefetch" href="/assets/js/34.c16c6ee1.js"><link rel="prefetch" href="/assets/js/35.13feed40.js"><link rel="prefetch" href="/assets/js/36.0c34aed6.js"><link rel="prefetch" href="/assets/js/37.9202d6c9.js"><link rel="prefetch" href="/assets/js/38.f8e129a2.js"><link rel="prefetch" href="/assets/js/39.0021dfc1.js"><link rel="prefetch" href="/assets/js/4.b39abf1d.js"><link rel="prefetch" href="/assets/js/40.d374cda1.js"><link rel="prefetch" href="/assets/js/41.eb48efb9.js"><link rel="prefetch" href="/assets/js/42.c2f93674.js"><link rel="prefetch" href="/assets/js/43.e2ce89c2.js"><link rel="prefetch" href="/assets/js/44.aaf30fa0.js"><link rel="prefetch" href="/assets/js/45.655cd797.js"><link rel="prefetch" href="/assets/js/46.757b1616.js"><link rel="prefetch" href="/assets/js/47.dfbd58c8.js"><link rel="prefetch" href="/assets/js/48.ddcab0e9.js"><link rel="prefetch" href="/assets/js/49.47ce1e24.js"><link rel="prefetch" href="/assets/js/5.4518cf99.js"><link rel="prefetch" href="/assets/js/50.2f72f340.js"><link rel="prefetch" href="/assets/js/51.51bf10d2.js"><link rel="prefetch" href="/assets/js/52.915d4928.js"><link rel="prefetch" href="/assets/js/53.050f68ad.js"><link rel="prefetch" href="/assets/js/54.2fca5495.js"><link rel="prefetch" href="/assets/js/55.9779c5a2.js"><link rel="prefetch" href="/assets/js/56.02b0dbbd.js"><link rel="prefetch" href="/assets/js/57.632fdb32.js"><link rel="prefetch" href="/assets/js/58.470f45fc.js"><link rel="prefetch" href="/assets/js/59.ad62ca3e.js"><link rel="prefetch" href="/assets/js/6.1185b8bd.js"><link rel="prefetch" href="/assets/js/60.36c90e5d.js"><link rel="prefetch" href="/assets/js/61.ecfed753.js"><link rel="prefetch" href="/assets/js/62.bd28e9c4.js"><link rel="prefetch" href="/assets/js/63.85dcd7b8.js"><link rel="prefetch" href="/assets/js/64.4d8ebbb4.js"><link rel="prefetch" href="/assets/js/65.ddaa4c0d.js"><link rel="prefetch" href="/assets/js/66.b275255b.js"><link rel="prefetch" href="/assets/js/67.f3c5c614.js"><link rel="prefetch" href="/assets/js/7.2127d0de.js"><link rel="prefetch" href="/assets/js/8.760e0ac9.js"><link rel="prefetch" href="/assets/js/9.01276f18.js">
    <link rel="stylesheet" href="/assets/css/0.styles.0d19fd84.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/zh/" class="home-link router-link-active"><!----> <span class="site-name">白 日 淡</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/zh/guide/" class="nav-link">指南</a></div><div class="nav-item"><a href="/zh/computer/" class="nav-link">计算机</a></div><div class="nav-item"><a href="/zh/sources/" class="nav-link">资源收集</a></div><div class="nav-item"><a href="/zh/guoxue/" class="nav-link">国学</a></div><div class="nav-item"><a href="https://www.jianshu.com/u/316beb0573ae" target="_blank" rel="noopener noreferrer" class="nav-link external">
  简书
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="/zh/unfilter/" class="nav-link">未分类</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/zh/guide/" class="nav-link">指南</a></div><div class="nav-item"><a href="/zh/computer/" class="nav-link">计算机</a></div><div class="nav-item"><a href="/zh/sources/" class="nav-link">资源收集</a></div><div class="nav-item"><a href="/zh/guoxue/" class="nav-link">国学</a></div><div class="nav-item"><a href="https://www.jianshu.com/u/316beb0573ae" target="_blank" rel="noopener noreferrer" class="nav-link external">
  简书
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="/zh/unfilter/" class="nav-link">未分类</a></div> <!----></nav>  <ul class="sidebar-links"><li><div class="sidebar-group first"><p class="sidebar-heading"><span>并发编程</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/zh/back-end/concurrency/" class="sidebar-link">并发编程专题</a></li></ul></div></li><li><div class="sidebar-group"><p class="sidebar-heading open"><span></span> <!----></p> <ul class="sidebar-group-items"><li><a href="/zh/back-end/concurrency/并发编程面试题.html" class="active sidebar-link">并发常见问题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/zh/back-end/concurrency/并发编程面试题.html#q1-synchroized原理？" class="sidebar-link">Q1:Synchroized原理？</a></li><li class="sidebar-sub-header"><a href="/zh/back-end/concurrency/并发编程面试题.html#q2-synchronized锁的使用？" class="sidebar-link">Q2:Synchronized锁的使用？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/zh/back-end/concurrency/并发编程面试题.html#方法锁" class="sidebar-link">方法锁</a></li><li class="sidebar-sub-header"><a href="/zh/back-end/concurrency/并发编程面试题.html#代码块" class="sidebar-link">代码块</a></li><li class="sidebar-sub-header"><a href="/zh/back-end/concurrency/并发编程面试题.html#锁的选择" class="sidebar-link">锁的选择</a></li></ul></li><li class="sidebar-sub-header"><a href="/zh/back-end/concurrency/并发编程面试题.html#q3-什么是可重入性，为什么synchronized是可重入锁？" class="sidebar-link">Q3:什么是可重入性，为什么Synchronized是可重入锁？</a></li><li class="sidebar-sub-header"><a href="/zh/back-end/concurrency/并发编程面试题.html#q4-synchronized优化？（todo）" class="sidebar-link">Q4:Synchronized优化？（todo）</a></li><li class="sidebar-sub-header"><a href="/zh/back-end/concurrency/并发编程面试题.html#q5-为什么说synchronized是非公平锁？" class="sidebar-link">Q5:为什么说Synchronized是非公平锁？</a></li><li class="sidebar-sub-header"><a href="/zh/back-end/concurrency/并发编程面试题.html#q6-什么是锁消除？什么是锁粗化？" class="sidebar-link">Q6:什么是锁消除？什么是锁粗化？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/zh/back-end/concurrency/并发编程面试题.html#锁消除" class="sidebar-link">锁消除</a></li><li class="sidebar-sub-header"><a href="/zh/back-end/concurrency/并发编程面试题.html#锁粗化" class="sidebar-link">锁粗化</a></li></ul></li><li class="sidebar-sub-header"><a href="/zh/back-end/concurrency/并发编程面试题.html#q7-为什么说synchronized是悲观锁？" class="sidebar-link">Q7:为什么说Synchronized是悲观锁？</a></li><li class="sidebar-sub-header"><a href="/zh/back-end/concurrency/并发编程面试题.html#q8-乐观锁一定好吗？" class="sidebar-link">Q8:乐观锁一定好吗？</a></li><li class="sidebar-sub-header"><a href="/zh/back-end/concurrency/并发编程面试题.html#q9-可重入锁reentrantlock与synchronized实现原理不同点？" class="sidebar-link">Q9:可重入锁ReentrantLock与Synchronized实现原理不同点？</a></li><li class="sidebar-sub-header"><a href="/zh/back-end/concurrency/并发编程面试题.html#q10-synchronized和reentrantlock的异同？" class="sidebar-link">Q10:Synchronized和ReentrantLock的异同？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/zh/back-end/concurrency/并发编程面试题.html#相同" class="sidebar-link">相同</a></li><li class="sidebar-sub-header"><a href="/zh/back-end/concurrency/并发编程面试题.html#区别" class="sidebar-link">区别</a></li></ul></li><li class="sidebar-sub-header"><a href="/zh/back-end/concurrency/并发编程面试题.html#q11-reentrantlock-是如何实现可重入性的？" class="sidebar-link">Q11:ReentrantLock 是如何实现可重入性的？</a></li><li class="sidebar-sub-header"><a href="/zh/back-end/concurrency/并发编程面试题.html#q12-除了reetrantlock，你还用过juc中哪些并发工具-todo-？" class="sidebar-link">Q12:除了ReetrantLock，你还用过JUC中哪些并发工具(todo)？</a></li><li class="sidebar-sub-header"><a href="/zh/back-end/concurrency/并发编程面试题.html#q13-readwritelock和stampedlock？" class="sidebar-link">Q13:ReadWriteLock和StampedLock？</a></li><li class="sidebar-sub-header"><a href="/zh/back-end/concurrency/并发编程面试题.html#q14-juc同步器？（todo）https-blog-csdn-net-faw67j7-article-details-79885944" class="sidebar-link">Q14:jUC同步器？（todo）https://blog.csdn.net/FAw67J7/article/details/79885944</a></li><li class="sidebar-sub-header"><a href="/zh/back-end/concurrency/并发编程面试题.html#q15-java线程池是如何实现的？" class="sidebar-link">Q15:java线程池是如何实现的？</a></li><li class="sidebar-sub-header"><a href="/zh/back-end/concurrency/并发编程面试题.html#q16-线程池的核心构造参数？" class="sidebar-link">Q16:线程池的核心构造参数？</a></li><li class="sidebar-sub-header"><a href="/zh/back-end/concurrency/并发编程面试题.html#q17-线程池中的线程是怎么被创建的？是一开始就随着线程池的创建而创建的吗？" class="sidebar-link">Q17:线程池中的线程是怎么被创建的？是一开始就随着线程池的创建而创建的吗？</a></li><li class="sidebar-sub-header"><a href="/zh/back-end/concurrency/并发编程面试题.html#q18-java中默认实现的线程池？并比较异同。" class="sidebar-link">Q18:java中默认实现的线程池？并比较异同。</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/zh/back-end/concurrency/并发编程面试题.html#singlethreadexecutor-单线程线程池" class="sidebar-link">SingleThreadExecutor 单线程线程池</a></li><li class="sidebar-sub-header"><a href="/zh/back-end/concurrency/并发编程面试题.html#fixedthreadpool-固定大小线程池" class="sidebar-link">FixedThreadpool 固定大小线程池</a></li><li class="sidebar-sub-header"><a href="/zh/back-end/concurrency/并发编程面试题.html#cachedthreadpool-缓存线程池" class="sidebar-link">CachedThreadPool 缓存线程池</a></li><li class="sidebar-sub-header"><a href="/zh/back-end/concurrency/并发编程面试题.html#scheduledthreadpool-调度线程池" class="sidebar-link">ScheduledThreadPool 调度线程池</a></li></ul></li><li class="sidebar-sub-header"><a href="/zh/back-end/concurrency/并发编程面试题.html#q19-java线程池中怎么提交任务" class="sidebar-link">Q19:java线程池中怎么提交任务</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/zh/back-end/concurrency/并发编程面试题.html#execute" class="sidebar-link">execute()</a></li><li class="sidebar-sub-header"><a href="/zh/back-end/concurrency/并发编程面试题.html#submit" class="sidebar-link">submit()</a></li></ul></li><li class="sidebar-sub-header"><a href="/zh/back-end/concurrency/并发编程面试题.html#q20-volatile是怎么保证变量对所有线程的可见性的？" class="sidebar-link">Q20:volatile是怎么保证变量对所有线程的可见性的？</a></li><li class="sidebar-sub-header"><a href="/zh/back-end/concurrency/并发编程面试题.html#q21-是否基于volatile变量的运算就能保证并发安全？" class="sidebar-link">Q21:是否基于volatile变量的运算就能保证并发安全？</a></li><li class="sidebar-sub-header"><a href="/zh/back-end/concurrency/并发编程面试题.html#q22-对比下-volatile-对比-synchronized-的异同？" class="sidebar-link">Q22:对比下 volatile 对比 Synchronized 的异同？</a></li><li class="sidebar-sub-header"><a href="/zh/back-end/concurrency/并发编程面试题.html#q23-现在有t1、t2、t3三个线程，你怎样保证t2在t1执行完后执行，t3在t2执行完后执行？" class="sidebar-link">Q23:现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行？</a></li><li class="sidebar-sub-header"><a href="/zh/back-end/concurrency/并发编程面试题.html#q24-java中wait和sleep方法的不同？" class="sidebar-link">Q24:java中wait和sleep方法的不同？</a></li></ul></li></ul></div></li></ul> </div> <div class="page"> <div class="content"><h1 id="并发常见问题"><a href="#并发常见问题" aria-hidden="true" class="header-anchor">#</a> 并发常见问题</h1> <h2 id="q1-synchroized原理？"><a href="#q1-synchroized原理？" aria-hidden="true" class="header-anchor">#</a> Q1:Synchroized原理？</h2> <p>Synchroized是由jvm实现的一种实现互斥同步的方式。查看编译后的字节码文件，发现其实是使用了monitorenter和monitoorexit指令。指令内部实现：</p> <ul><li>当指令运行到monitorenter时，获取锁，把锁的计数器+1。</li> <li>当指令运行到monitorexit时，锁计数器-1。</li> <li>当锁计数器为0时，锁被释放。</li> <li>如果获取锁失败，则当前线程阻塞等待，直到获取锁。</li></ul> <h2 id="q2-synchronized锁的使用？"><a href="#q2-synchronized锁的使用？" aria-hidden="true" class="header-anchor">#</a> Q2:Synchronized锁的使用？</h2> <p>Synchronized的用法有两种，分别是Synchronized方法和Synchronized块。如：</p> <p align="center"><img src="http://qiniu.xuchen.link/503115f3315fedc5f9e2465ecdcd9f66.png" title="synchronized使用示例" width="340" height="210"></p><h3 id="方法锁"><a href="#方法锁" aria-hidden="true" class="header-anchor">#</a> 方法锁</h3> <p>方法所又分为锁实例方法和锁静态方法。</p> <p>使用示例方法锁时，当一个类有多个实例时，调用该方法时不一定能拿到锁，只有当调用的是同一个实例的该方法才能使用同一个锁，达到加锁的效果。</p> <div class="language-java extra-class"><pre class="language-java"><code>  <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//todo</span>
  <span class="token punctuation">}</span>
</code></pre></div><p>使用静态方法锁时，锁住的是类对象，是唯一的，所以在调用静态方法的锁时，使用的是同一把锁，可以满足加锁效果。</p> <div class="language-java extra-class"><pre class="language-java"><code>  <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">//todo</span>
  <span class="token punctuation">}</span>
</code></pre></div><h3 id="代码块"><a href="#代码块" aria-hidden="true" class="header-anchor">#</a> 代码块</h3> <p>代码块中可以传入实例对象或类对象或实例对象的object。</p> <p>锁实例对象时，所得是该类的实例对象，要使锁起效，需要确保加锁的是同一个实例。</p> <div class="language-java extra-class"><pre class="language-java"><code>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">//todo</span>
        <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</code></pre></div><p>锁类的实例对象时，由于类是唯一的，所以在调用时满足加锁效果。</p> <div class="language-java extra-class"><pre class="language-java"><code>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">Foo</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">//todo</span>
        <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</code></pre></div><p>锁实例对象object时，需要根据传入的对象来加锁，常见是传入String对象作为锁。</p> <div class="language-java extra-class"><pre class="language-java"><code>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">String</span> lock <span class="token operator">=</span> “test”<span class="token punctuation">;</span>
        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">//todo</span>
        <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</code></pre></div><h3 id="锁的选择"><a href="#锁的选择" aria-hidden="true" class="header-anchor">#</a> 锁的选择</h3> <p>方法锁的锁颗粒度较大，在并发编程中会造成效率低下。因此在场景允许的情况下，尽量的使用颗粒度更小的锁。对需要操作的部分代码进行代码块级别的加锁，从而达到提升效率。</p> <h2 id="q3-什么是可重入性，为什么synchronized是可重入锁？"><a href="#q3-什么是可重入性，为什么synchronized是可重入锁？" aria-hidden="true" class="header-anchor">#</a> Q3:什么是可重入性，为什么Synchronized是可重入锁？</h2> <p>当前线程拿到锁之后，同一个类中一个同步方法调用另一个同步方法也仍可以获取锁，而不会导致死锁，就实现了可重入。</p> <p>Synchronized在内部维护了锁拥有者和计数器。重入时计数器加1，同步方法结束时计数器减1，当计数器为0时释放锁。其他线程发现锁拥有者不是自己时，就会进行等待，直到可获取锁。</p> <h2 id="q4-synchronized优化？（todo）"><a href="#q4-synchronized优化？（todo）" aria-hidden="true" class="header-anchor">#</a> Q4:Synchronized优化？（todo）</h2> <p>使用CAS操作使线程不需进行阻塞的操作，减少线程状态切换。
锁实现效率从低到高 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁。jvm会根据锁竞争状态进行升级。
<code>todo</code>据说升级后不能降级？</p> <h2 id="q5-为什么说synchronized是非公平锁？"><a href="#q5-为什么说synchronized是非公平锁？" aria-hidden="true" class="header-anchor">#</a> Q5:为什么说Synchronized是非公平锁？</h2> <p>非公平性主要体现在获取锁的行为上，并不是按照申请锁的先后顺序分配锁。而是在锁释放之后，每一个等待锁的线程都有可能获取到锁。</p> <ul><li>优点：提高了执行效率。</li> <li>缺点：产生线程饥饿现象。</li></ul> <h2 id="q6-什么是锁消除？什么是锁粗化？"><a href="#q6-什么是锁消除？什么是锁粗化？" aria-hidden="true" class="header-anchor">#</a> Q6:什么是锁消除？什么是锁粗化？</h2> <h3 id="锁消除"><a href="#锁消除" aria-hidden="true" class="header-anchor">#</a> 锁消除</h3> <p>根据逃逸分析，判断对象的使用是否会被外部的方法作为一个全局对象使用。如果会则可能发生线程安全问题，此时就发生了锁逃逸。如果不会发生锁逃逸，虚拟机进行锁消除操作，忽略同步而直接运行。</p> <h3 id="锁粗化"><a href="#锁粗化" aria-hidden="true" class="header-anchor">#</a> 锁粗化</h3> <p>锁的作用粒度是越小越好，但是如果一系列的操作要反复的进行加锁和释放锁操作，会导致不必要的性能损耗，此时可以适当的增加锁的作用域，即锁粗化。</p> <h2 id="q7-为什么说synchronized是悲观锁？"><a href="#q7-为什么说synchronized是悲观锁？" aria-hidden="true" class="header-anchor">#</a> Q7:为什么说Synchronized是悲观锁？</h2> <p>Synchronized的加锁策略是：不管会不会产生锁竞争，都先进行加锁，先尝试获取锁，如果没有竞争则执行同步代码块，如果发生了竞争则等锁释放再获取锁进行加锁。
乐观锁的核心算法是CAS，策略是比较执行，先执行，如果没有竞争则修改为新值，如果发生竞争则舍弃本次操作。</p> <h2 id="q8-乐观锁一定好吗？"><a href="#q8-乐观锁一定好吗？" aria-hidden="true" class="header-anchor">#</a> Q8:乐观锁一定好吗？</h2> <p>cas避免了独占锁的现象，能提高并发性能。
缺点如下：</p> <ol><li>乐观锁只能保证一个共享变量的原子操作。</li> <li>长时间的自旋会导致cpu的开销大。</li> <li>ABA问题，第一次对比时值是A，之后被另一线程改为B，又被另一线程改为A，第二次读取时发现是A。cas认为值没有被改变。可以引入版本号来解决aba问题。</li></ol> <h2 id="q9-可重入锁reentrantlock与synchronized实现原理不同点？"><a href="#q9-可重入锁reentrantlock与synchronized实现原理不同点？" aria-hidden="true" class="header-anchor">#</a> Q9:可重入锁ReentrantLock与Synchronized实现原理不同点？</h2> <p>Synchronized是JVM原生的锁的实现方式。ReentrantLock是基于Lock接口的一个实现类，本质是一个AQS框架（AbstractQueuedSynchronizer）来实现。</p> <h2 id="q10-synchronized和reentrantlock的异同？"><a href="#q10-synchronized和reentrantlock的异同？" aria-hidden="true" class="header-anchor">#</a> Q10:Synchronized和ReentrantLock的异同？</h2> <p>Synchronized是一个java的关键字，ReentrantLock是java的Lock接口下的一个实现类。以下简称Synchronized为内置锁，ReentrantLock为重入锁。</p> <h3 id="相同"><a href="#相同" aria-hidden="true" class="header-anchor">#</a> 相同</h3> <ul><li>加锁方式同步</li> <li>同步都是阻塞的</li> <li>都是可重入的锁</li></ul> <h3 id="区别"><a href="#区别" aria-hidden="true" class="header-anchor">#</a> 区别</h3> <ul><li>构成方式不同，内置锁是java提供的关键字，重入锁是JDK1.5之后的API层面的互斥锁。</li> <li>使用方式不同，内置锁无须显式的获取和释放锁，重入锁需要显式的获取和释放锁。</li> <li>灵活性不同，内置锁不可中断，除非抛出异常，重入锁可以。
<ul><li>内置锁中断方式：
<ol><li>代码执行完毕，正常释放锁。</li> <li>抛出异常，jvm退出等待。</li></ol></li> <li>重入锁中断方式：
<ol><li>tryLock((long timeout, TimeUnit unit)，超时退出。</li> <li>lockInterruptibly()，调用interrupt()方法可中断。</li></ol></li></ul></li> <li>是否允许公平锁，内置锁是非公平锁，重入锁默认（无参构造器）为不公平锁，可以选择非公平锁（传入true为公平锁，false为不公平锁）。</li> <li>是否提供非阻塞获取锁方式，内置锁不支持，重入锁可用tryLock()，返回的是一个boolean类型。根据boolean执行不同的方法。也可以tryLock(long timeout, TimeUnit unit)，等待一段时间获取锁，在时间内获取锁则返回true，否则false。</li> <li>锁是否可以绑定条件，内置锁不可以，重入锁可以同时绑定多个Condition实例。</li> <li>性能，java6之前内置锁性能明显低于重入锁，之后再低竞争情况下，内置锁优于重入锁，高竞争内置锁性能下降，而重入锁基本维持常态。</li></ul> <h2 id="q11-reentrantlock-是如何实现可重入性的？"><a href="#q11-reentrantlock-是如何实现可重入性的？" aria-hidden="true" class="header-anchor">#</a> Q11:ReentrantLock 是如何实现可重入性的？</h2> <p>ReentrantLock内部的同步器Sync实现了CAS算法，把线程对象放在了一个双向链表结构中，每次获取锁都会进行比较维护的线程ID和当前线程ID是否一致，一致即可重入。</p> <h2 id="q12-除了reetrantlock，你还用过juc中哪些并发工具-todo-？"><a href="#q12-除了reetrantlock，你还用过juc中哪些并发工具-todo-？" aria-hidden="true" class="header-anchor">#</a> Q12:除了ReetrantLock，你还用过JUC中哪些并发工具(todo)？</h2> <ul><li>ConcurrentHashMap等线程安全的容器</li> <li>ArrayBlockingQueue、PriorityBlockingQueue等并发队列</li> <li>Executor框架的线程池</li> <li>AtomicInteger等原子操作类</li> <li>TimeUnit</li></ul> <h2 id="q13-readwritelock和stampedlock？"><a href="#q13-readwritelock和stampedlock？" aria-hidden="true" class="header-anchor">#</a> Q13:ReadWriteLock和StampedLock？</h2> <p>ReadWriteLock是java1.5提供的读写锁。并发情况下，读读不锁，读写，写写会锁，用于进行读写分离。在读操作远远大于写操作的情况下，性能提高明显。
但是在实际应用中，ReadWriteLock的性能不好，因此提供了新的StampedLock,基于CLH，获取锁的方式是一个long类型的票据（stamp），是保证不会产生饥饿且FIFO。StampedLock是一个不可重入锁。SteampedLock的乐观读机制在大量读操作，少量写操作时，能提供极高的性能。</p> <h2 id="q14-juc同步器？（todo）https-blog-csdn-net-faw67j7-article-details-79885944"><a href="#q14-juc同步器？（todo）https-blog-csdn-net-faw67j7-article-details-79885944" aria-hidden="true" class="header-anchor">#</a> Q14:jUC同步器？（todo）https://blog.csdn.net/FAw67J7/article/details/79885944</h2> <h2 id="q15-java线程池是如何实现的？"><a href="#q15-java线程池是如何实现的？" aria-hidden="true" class="header-anchor">#</a> Q15:java线程池是如何实现的？</h2> <p>java中的threadpool中有两个重要的成员属性。workqueue和works，workqueue中存放所有需要执行的任务，works中进行处理。</p> <h2 id="q16-线程池的核心构造参数？"><a href="#q16-线程池的核心构造参数？" aria-hidden="true" class="header-anchor">#</a> Q16:线程池的核心构造参数？</h2> <ul><li><code>corePoolSize</code>：线程池的核心线程数</li> <li><code>maximumPoolSize</code>：线程池允许的最大线程数</li> <li><code>keepAliveTime</code>：超过核心线程数时闲置线程的存活时间</li> <li><code>workQueue</code>：线程等待队列</li></ul> <h2 id="q17-线程池中的线程是怎么被创建的？是一开始就随着线程池的创建而创建的吗？"><a href="#q17-线程池中的线程是怎么被创建的？是一开始就随着线程池的创建而创建的吗？" aria-hidden="true" class="header-anchor">#</a> Q17:线程池中的线程是怎么被创建的？是一开始就随着线程池的创建而创建的吗？</h2> <p>线程池默认初始化后不启动Worker，等待有请求才会启动。每当调用execute()方法时，线程池会做如下判断：</p> <ul><li>如果正在运行的线程数量小于<code>corePoolSize</code>，那么立马创建线程运行这个任务。</li> <li>如果正在运行的线程数量大于或等于<code>corePoolSize</code>,那么这个任务放入队列。</li> <li>如果队列满了，且正在运行线程数量小于<code>maximumPoolSize</code>，那么创建非核心线程立即运行任务。</li> <li>如果队列满了，且正在运行的线程数量大于或等于<code>maximumPoolSize</code>，则线程池会抛出异常<code>RejectExecutionException</code>。</li> <li>当一个任务完成时，将会从队列中取下一个任务来执行。</li> <li>当线程空闲时间超过<code>keepAliveTime</code>时，如果当前运行线程数大于<code>corePoolSize</code>，则线程就会被销毁。直到线程数为<code>corePoolSize</code>大小。</li></ul> <h2 id="q18-java中默认实现的线程池？并比较异同。"><a href="#q18-java中默认实现的线程池？并比较异同。" aria-hidden="true" class="header-anchor">#</a> Q18:java中默认实现的线程池？并比较异同。</h2> <h3 id="singlethreadexecutor-单线程线程池"><a href="#singlethreadexecutor-单线程线程池" aria-hidden="true" class="header-anchor">#</a> SingleThreadExecutor 单线程线程池</h3> <p>线程池中只有一个核心线程，最大线程数也是1。如果这个线程因为异常结束，则会有新的线程来替代。该线程池可以保证任务按提交顺序执行。</p> <ul><li><code>corePoolSize</code>：1</li> <li><code>maximumPoolSize</code>：1</li> <li><code>keepAliveTime</code>：0L</li> <li><code>workQueue</code>：<code>new LinkedBlockQueue&lt;Runnable&gt;()</code></li></ul> <h3 id="fixedthreadpool-固定大小线程池"><a href="#fixedthreadpool-固定大小线程池" aria-hidden="true" class="header-anchor">#</a> FixedThreadpool 固定大小线程池</h3> <p>线程池中的线程大小固定不变，每次excute()就产生一个线程，知道上线。如果线程异常结束，则生成一个线程补充。</p> <ul><li><code>corePoolSize</code>：n</li> <li><code>maximumPoolSize</code>：n</li> <li><code>keepAliveTime</code>：0L</li> <li><code>workQueue</code>：<code>new LinkedBlockQueue&lt;Runnable&gt;()</code></li></ul> <h3 id="cachedthreadpool-缓存线程池"><a href="#cachedthreadpool-缓存线程池" aria-hidden="true" class="header-anchor">#</a> CachedThreadPool 缓存线程池</h3> <p>最大线程数不做限制，只要有新的任务就创建一个线程。线程空闲60后被销毁。<code>SynchronousQueue</code>是一个队列大小为1的阻塞队列。</p> <ul><li><code>corePoolSize</code>：0</li> <li><code>maximumPoolSize</code>：<code>Integer.MAX_VALUE</code></li> <li><code>keepAliveTime</code>：60L</li> <li><code>workQueue</code>：<code>new SynchronousQueue&lt;Runnable&gt;()</code></li></ul> <h3 id="scheduledthreadpool-调度线程池"><a href="#scheduledthreadpool-调度线程池" aria-hidden="true" class="header-anchor">#</a> ScheduledThreadPool 调度线程池</h3> <p>核心线程数固定，最大线程数无界。支持定时已经周期性的执行任务的线程池。</p> <ul><li><code>corePoolSize</code>：n</li> <li><code>maximumPoolSize</code>：<code>Integer.MAX_VALUE</code></li> <li><code>keepAliveTime</code>：0</li> <li><code>workQueue</code>：<code>new DelayedWorkQueue&lt;Runnable&gt;()</code></li></ul> <h2 id="q19-java线程池中怎么提交任务"><a href="#q19-java线程池中怎么提交任务" aria-hidden="true" class="header-anchor">#</a> Q19:java线程池中怎么提交任务</h2> <h3 id="execute"><a href="#execute" aria-hidden="true" class="header-anchor">#</a> execute()</h3> <p><code>ExecutorService.execute()</code>接收一个<code>Runnable</code>实例。</p> <h3 id="submit"><a href="#submit" aria-hidden="true" class="header-anchor">#</a> submit()</h3> <p><code>ExecutorService.submit()</code>返回一个<code>Future</code>实例。</p> <h2 id="q20-volatile是怎么保证变量对所有线程的可见性的？"><a href="#q20-volatile是怎么保证变量对所有线程的可见性的？" aria-hidden="true" class="header-anchor">#</a> Q20:volatile是怎么保证变量对所有线程的可见性的？</h2> <p>当共享变量的值被修改后，会立即刷新到主内存中。当其他线程需要读取共享变量时，会去主内存中获取新值。</p> <p>被volatile关键字修饰的变量，具有两层语义：</p> <ul><li>保证变量的可见性</li> <li>禁止进行指令重排</li></ul> <h2 id="q21-是否基于volatile变量的运算就能保证并发安全？"><a href="#q21-是否基于volatile变量的运算就能保证并发安全？" aria-hidden="true" class="header-anchor">#</a> Q21:是否基于volatile变量的运算就能保证并发安全？</h2> <p>不是，volatile不能保证原子性。所以在并发操作下也不安全。</p> <h2 id="q22-对比下-volatile-对比-synchronized-的异同？"><a href="#q22-对比下-volatile-对比-synchronized-的异同？" aria-hidden="true" class="header-anchor">#</a> Q22:对比下 volatile 对比 Synchronized 的异同？</h2> <p>volatile只保证了可见性，不保证原子性；而Synchronized既保证了可见性，也保证了原子性。</p> <h2 id="q23-现在有t1、t2、t3三个线程，你怎样保证t2在t1执行完后执行，t3在t2执行完后执行？"><a href="#q23-现在有t1、t2、t3三个线程，你怎样保证t2在t1执行完后执行，t3在t2执行完后执行？" aria-hidden="true" class="header-anchor">#</a> Q23:现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行？</h2> <p>使用join，运行的时候按照</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">//other....</span>
t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
t3<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
t3<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//other....</span>
</code></pre></div><h2 id="q24-java中wait和sleep方法的不同？"><a href="#q24-java中wait和sleep方法的不同？" aria-hidden="true" class="header-anchor">#</a> Q24:java中wait和sleep方法的不同？</h2> <p>wait是Object类中的方法，在等待时会释放锁。sleep是Thread类中的方法，会一直持有锁。wait常用于线程之间的交互，而sleep用于线程的暂停。</p></div> <div class="page-edit"><!----> <!----></div> <!----> </div> <!----></div></div>
    <script src="/assets/js/app.07421936.js" defer></script><script src="/assets/js/19.43aa5948.js" defer></script>
  </body>
</html>
